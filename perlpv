#!/usr/bin/env perl

use Time::HiRes qw(clock_gettime CLOCK_MONOTONIC alarm);
use Errno (EINTR);

# We need to turn off buffering of STDOUT to get rapid display of progress.
STDOUT->autoflush(1);

my $cursorup = "\033[1A";
my $cursordown = "\033[1B";
my $beginline = "\033[1E";
my $cleartoend = "\033[K";
my $clearline = $beginline . $cursorup . $cleartoend;

my $SOURCE = $ARGV[0];
my $TARGET = $ARGV[1];

# Set transfer blocksize to 1MiB. This doesn't appear to affect transfer rate MUCH, at least on my (i9-12900K) system. But it 
#                                 does appear SLIGHTLY faster, at least for the inital couple of seconds, than using 64KiB.
my $blocksize = 1024 * 1024;   

my $begin = monotime;

	my $size = open_files($SOURCE, $TARGET, $blocksize);

	transfer_data($size);

	close_files($SOURCE, $TARGET);

my $end = monotime;

exit 0;

sub monotime {
	clock_gettime(CLOCK_MONOTONIC)
}

sub transfer_data {
	my $source_size = shift;

	# perl sysread returns a value equal to the number of bytes read, or 0 if it's past EOF.
	# -1 is used to indicate timeout here
	my $returncode = -1;

	my $total_bytes_read=0;
	my $begin = monotime;
	my $last_printed = monotime;

	# We need to keep a running tally of point-in-time transfer rates for improved accuracy
	# in progress bar completion estimates.
	my @rate_history;

	# We need to handle the final displayed progress update slightly differently at the end.
	my $final_progress_update = 0;

	my $alarmed = 0;

	# Set up an alarm timer
	local $SIG{'ALRM'} = sub {
		$alarmed = 1;
	};

	alarm(0.5, 0.5);

	# dump a clean newline in at the start, so we don't erase existing stuff in the terminal
	print "\n";

	my $timestamp_before_reading = monotime;
	my $current_bytes_read = 0;
	my $buffer_pending_bytes = 0;
	my $buffer = '';

	while ($returncode ne 0 || $buffer_pending_bytes ne 0) {
		if ($buffer_pending_bytes eq 0) {
			$buffer = '';
			$returncode = sysread(SOURCE, $buffer, $blocksize);

			unless (defined($returncode)) {
				die "Error reading from $SOURCE: $!" unless $!{EINTR};
				$returncode = -1;
			}

			if ($returncode > 0) {
				$current_bytes_read += $returncode;
				$buffer_pending_bytes = $returncode;
			}
		}

		if ($buffer_pending_bytes ne 0) {
			my $written = syswrite(TARGET, $buffer, $buffer_pending_bytes,
				length($buffer) - $buffer_pending_bytes);

			unless (defined($written)) {
				die $! ? "Error writing to $TARGET: $!" : "Exit status $? from $TARGET"
					unless $!{EINTR};
				$written = -1;
			}

			if ($written > 0) {
				$buffer_pending_bytes -= $written;
			}
		}

		if ($alarmed || $returncode eq 0) {
			my $timestamp_after_writing = monotime;

			$total_bytes_read += $current_bytes_read;
			# calculate transfer rate of this block
			my $current_time_elapsed = $timestamp_after_writing - $timestamp_before_reading;
			if ($current_time_elapsed eq 0) { $current_time_elapsed = 1; }
			my $instantaneous_transfer_rate = ( $current_bytes_read / $current_time_elapsed );

			push (@rate_history,"$timestamp_after_writing,$instantaneous_transfer_rate");

			my $time_elapsed = $timestamp_after_writing - $begin;

			display_progress ($total_bytes_read, $source_size, $time_elapsed, \@rate_history,$final_progress_update);

			$alarmed = 0;
			$timestamp_before_reading = monotime;
			$current_bytes_read = 0;
		}
	}

	alarm(0);
	$final_progress_update = 1;

	# don't use monotime directly in an equation. assign it to a variable first or you will NOT get coherent results.
	my $end = monotime;
	my $time_elapsed = $end - $begin;
	display_progress ($total_bytes_read, $source_size, $time_elapsed, \@rate_history,$final_progress_update);
}

sub display_progress {
	my $total_bytes_read = shift;
	my $source_size = shift;
	my $time_elapsed = shift;
	my $rate_history_reference = shift;
	my $final_progress_update = shift;
	
	my $printable_bytes_read = printable_bytes ($total_bytes_read);

	# process @rate_history to get 5m, 1m, 10s, and most-recent average rates
	my @five_minute_rate;
	my @one_minute_rate;
	my @ten_second_rate;
	my $now = monotime;

	for my $index (reverse 0 .. (scalar(@{$rate_history_reference})-1) ) {
		my $row = ${$rate_history_reference}[$index];

		my ($time,$rate) = split(/,/,$row);
		my $age = $now-$time;

		# transfers that happened in the last ten seconds
		if ($age <= 10) { push (@ten_second_rate,$rate); }
		# transfers that happened in the last minute
		if ($age <= 60) { push (@one_minute_rate,$rate); }
		# transfers that happened in the last five minutes
		if ($age <= 60*5) { push (@five_minute_rate,$rate); ;}
		# remove any rows older than five minutes
		if ($age > 5*60) { 
			splice (@{$rate_history_reference}, $index); 
		}
	}

	# put together 5m,1m,and 10s rolling averages
	my $five_minute_mean = average_array(@five_minute_rate);
	my $one_minute_mean = average_array(@one_minute_rate);
	my $ten_second_mean = average_array(@ten_second_rate);
	my $printable_aggregate_mean = printable_bytes($total_bytes_read/$time_elapsed) . "/sec";

	# get the instaneous (most recent single block) rate
	my $rate_history_elements = scalar (@{$rate_history_reference});
	my $current_row = ${$rate_history_reference}[$rate_history_elements-1];
	my ($current_time,$current_rate) = split (/,/,$current_row);
	
	# average our four rates to get a final guesstimated rate
	my @non_null_rates;
	if ($#five_minute_mean) { push (@non_null_rates,$five_minute_mean); }
	if ($#one_minute_mean) { push (@non_null_rates,$five_minute_mean); }
	if ($#ten_second_mean) { push (@non_null_rates,$five_minute_mean); }
	if ($current_rate) { push (@non_null_rates,$current_rate); }
	my $transfer_rate = average_array (@non_null_rates);
	my $display_transfer_rate = printable_bytes ($transfer_rate) . "/sec";
	my $printable_current_rate = printable_bytes ($current_rate) . "/sec";

	my $remaining_data = $source_size - $total_bytes_read;

	# clear last status line before printing a new one
	print STDERR $clearline;

	my $display_source_size;
	if ($source_size) { $display_source_size = " of " . printable_bytes ($source_size); }

	my $estimated_time_remaining;
	my $display_estimated_time_remaining;

	if ($source_size && $remaining_data && $transfer_rate) {
		$estimated_time_remaining = $remaining_data / $transfer_rate;
		$display_estimated_time_remaining = ", estimated completion in " . printable_seconds($estimated_time_remaining) ;
	}
	
	if ($final_progress_update) {
		print STDERR "    Transferred $printable_bytes_read" . $display_source_size . " (AVG $printable_aggregate_mean) in " . printable_seconds($time_elapsed) . "\n";
	} else {
		print STDERR "    Transferred $printable_bytes_read" . $display_source_size . " (AVG $printable_aggregate_mean CUR $printable_current_rate)" . $display_estimated_time_remaining . "\n";
	}
	$last_printed = monotime;
}

sub average_array {
	my @array = @_;
	my $sum;
	if ($#array < 1) { return 0; }
	foreach (@array) { $sum+= $_; }
	return $sum/$#array;
}

sub printable_seconds {
	my $seconds = shift;
	my $printable_seconds;

	my $days;
	my $hours;
	my $minutes;

	if ($seconds >= 60*60*24) {
		$days = sprintf("%d",$seconds/60/60/24);
		$seconds = $seconds - $days*60*60*24;
	}

	if ($seconds >= 60*60) {
		$hours = sprintf("%d",($seconds/60/60));
		$seconds = $seconds - $hours*60*60;
	}

	if ($seconds >=60) {
		$minutes = sprintf("%d",($seconds/60));
		$seconds = $seconds - $minutes*60;
	}

	$hours = sprintf("%02d",$hours);
	$minutes = sprintf("%02d",$minutes);
	$seconds = sprintf("%02d",$seconds);

	$printable_seconds = "$hours:$minutes:$seconds";
	if ($days) { $printable_seconds = "$days days, $printable_seconds"; }

	return $printable_seconds;
}

sub printable_bytes {
	my $bytes = shift;
	my $printable_bytes;

        if ($bytes >= 1024*1024*1024*1024) {
                $printable_bytes = sprintf("%.1f",$bytes/1024/1024/1024/1024) . 'TiB';
        } elsif ($bytes >= 1024*1024*1024) {
                $printable_bytes = sprintf("%.1f",$bytes/1024/1024/1024) . 'GiB';
        } elsif ($bytes >= 1024*1024) {
                $printable_bytes = sprintf("%.1f",$bytes/1024/1024) . 'MiB';
        } else {
                $printable_bytes = sprintf("%d",$bytes/1024) . 'KiB';
        }

	return $printable_bytes;
}

sub close_files {

	my $SOURCE = shift;
	my $TARGET = shift;

	close SOURCE
		or die $! ? "Error closing source file $SOURCE: $!"
		: "Exit status $? from $SOURCE\n";
	close TARGET
		or die $! ? "Error closing target file $TARGET: $!"
		: "Exit status $? from $TARGET\n";
}

sub open_files {

	my $SOURCE = shift;
	my $TARGET = shift;
	my $blocksize = shift;

	# if SOURCE is a file, a -s check is all we need to find its size
	my $size = -s $SOURCE;

	if (-b $SOURCE || -c $SOURCE) { 
		# this is a block device or character device, -s won't work
		open TEST, "<", $SOURCE;
		seek TEST, 0, 2;
		$size = tell TEST;
		close TEST;
	}

	sysopen SOURCE, $SOURCE, "O_RDONLY"
        	or die $! ? "Error opening source file $SOURCE: $!"
	        : "Exit status $? from sysopen SOURCE,$SOURCE,O_RDONLY\n";
	binmode SOURCE;

	open TARGET, ">", "$TARGET"
        	or die $! ? "Error opening target file $TARGET: $!"
	        : "Exit status $? from open TARGET,>,$TARGET\n";
	binmode TARGET;

	return $size;
}
