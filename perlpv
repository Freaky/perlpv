#!/usr/bin/env perl

use strict;
use warnings;
use utf8;

use Errno qw(EINTR);
use Fcntl qw(O_RDONLY);
use List::Util qw(pairs);
use Time::HiRes qw(clock_gettime CLOCK_MONOTONIC alarm);

# apt install libterm-readkey-perl on Debian derivatives eg Ubuntu
use Term::ReadKey;

# We need to turn off buffering of STDERR to get rapid display of progress.
STDERR->autoflush(1);
binmode(STDERR, ":encoding(UTF-8)");

my $cursorup = "\033[1A";
my $cursordown = "\033[1B";
my $beginline = "\033[1E";
my $cleartoend = "\033[K";
my $clearline = $beginline . $cleartoend;

# Set transfer blocksize to 512KiB. This doesn't appear to affect transfer rate MUCH, at least on my
# (i9-12900K) system. But it does appear SLIGHTLY faster, at least for the inital couple of seconds,
# than using 64KiB.
my $blocksize = 1024 * 512;

if (scalar(@ARGV) % 2 != 0) {
	die "Usage: $0 SOURCE DEST [..]";
}

my $total_size = 0;
my $known_size = 1;
my @tasks;

for my $pair (pairs @ARGV) {
	my ($source, $target) = @$pair;
	my $size = file_size($source);

	if (defined($size)) {
		$total_size += $size;
	} else {
		$known_size = 0;
	}

	push(@tasks, {'source' => $source, 'target' => $target, 'size' => $size});
}

for my $task (@tasks) {
	transfer_data($task);
}

exit 0;

sub monotime {
	clock_gettime(CLOCK_MONOTONIC)
}

sub transfer_data {
	my $task = shift;
	my ($source, $target, $source_size) = ($task->{'source'}, $task->{'target'}, $task->{'size'});
	my ($in, $out) = open_files($source, $target);

	my $finished = 0;
	my $alarmed = 0;

	# Set up a SIGALRM timer to interrupt us periodically to update statistics
	local $SIG{'ALRM'} = sub {
		$alarmed = 1;
	};

	alarm(0.5, 0.5);

	# Number of bytes from the previous read, 0 at EOF, or -1 on SIGALRM interrupt
	my $bytes_read = -1;

	# Total bytes read since the last progress update
	my $current_bytes_read = 0;

	# Bytes in buffer remaining to write
	my $buffer_pending_bytes = 0;
	my $buffer;

	my $progress = progress_init($source_size || 0);

	# Loop until we have both exhausted the input and cleared the output buffer
	until ($finished) {
		# Try reading if the buffer is empty and we haven't previously hit EOF
		if ($buffer_pending_bytes == 0 && $bytes_read != 0) {
			# Try to refill our empty buffer
			$buffer = '';
			$bytes_read = sysread($in, $buffer, $blocksize);

			if (defined($bytes_read)) {
				$current_bytes_read += $bytes_read;
				$buffer_pending_bytes = $bytes_read;
			} elsif ($! == EINTR) {
				$bytes_read = -1;
			} else {
				die "Error reading from $source: $!";
			}
		}

		if ($buffer_pending_bytes != 0) {
			# Try to drain the non-empty buffer
			my $bytes_written = syswrite($out, $buffer, $buffer_pending_bytes,
				length($buffer) - $buffer_pending_bytes);

			if (defined($bytes_written)) {
				$buffer_pending_bytes -= $bytes_written;
			} elsif ($! != EINTR) {
				die $! ? "Error writing to $target: $!" : "Exit status $? from $target";
			}
		}

		$finished = $bytes_read == 0 && $buffer_pending_bytes == 0;

		# Record stats if we've received SIGALRM or have hit EOF and finished writing
		if ($alarmed || $finished) {
			progress_update($progress, $current_bytes_read);
			progress_finish() if $finished;

			$alarmed = 0;
			$current_bytes_read = 0;
		}
	}
	alarm(0);
	close_files($task, $in, $out);
}

sub open_files {
	my $source = shift;
	my $target = shift;

	# Seems a bit arbitrary to sysopen one and open the other?
	# I don't think it matters either way
	sysopen my $in, $source, O_RDONLY
		or die $! ? "Error opening source file $source: $!"
		: "Exit status $? from sysopen SOURCE,$source,O_RDONLY\n";
	binmode $in;

	open my $out, ">", "$target"
		or die $! ? "Error opening target file $target: $!"
		: "Exit status $? from open TARGET,>,$target\n";
	binmode $out;

	return ($in, $out);
}

sub close_files {
	my $task = shift;
	my $source = shift;
	my $target = shift;

	# Errors from writing are more likely, but also more critical, so close that first
	close $target
		or die $! ? "Error closing target file $task->{'target'}: $!"
		: "Exit status $? from $task->{'target'}\n";

	close $source
		or die $! ? "Error closing source file $task->{'source'}: $!"
		: "Exit status $? from $task->{'source'}\n";
}

sub file_size {
	my $path = shift;
	my $size;

	if (-b $path || -c $path) {
		if (open TEST, "<", $path) {
			seek TEST, 0, 2;
			$size = tell TEST;
			close TEST;
		}
	} else {
		$size = -s $path;
	}

	return $size;
}


# Formatting and stats functions

sub printable_seconds {
	my $seconds = shift;
	my $printable_seconds;

	my $days = 0;
	my $hours = 0;
	my $minutes = 0;

	if ($seconds >= 60*60*24) {
		$days = sprintf("%d",$seconds/60/60/24);
		$seconds = $seconds - $days*60*60*24;
	}

	if ($seconds >= 60*60) {
		$hours = sprintf("%d",($seconds/60/60));
		$seconds = $seconds - $hours*60*60;
	}

	if ($seconds >=60) {
		$minutes = sprintf("%d",($seconds/60));
		$seconds = $seconds - $minutes*60;
	}

	$hours = sprintf("%02d",$hours);
	$minutes = sprintf("%02d",$minutes);
	$seconds = sprintf("%02d",$seconds);

	$printable_seconds = "$hours:$minutes:$seconds";
	if ($days) { $printable_seconds = "$days days, $printable_seconds"; }

	return $printable_seconds;
}

# ZFS-style number formatting
# Takes a byte size and a character length to fit the formatted value within
sub printable_bytes {
	my $num = shift;
	my $length = shift || 5;

	my @size_prefix = ('B', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y');
	my @formats = ('%*.2f%s', '%*.1f%s', '%*.0f%s');
	my $divisor = 1024;

	my $n = $num;
	my $index = 0;
	while ($n >= $divisor && $index <= ($#size_prefix - 1)) {
		$n /= $divisor;
		$index++;
	}

	my $u = $size_prefix[$index];

	if ($index == 0 || $num % ($divisor ** $index) == 0) {
		return sprintf("%*d%s", $length - 1, $n, $u);
	}

	my $ret;
	foreach my $fmt (@formats) {
		$ret = sprintf($fmt, $length - 1, $n, $u);
		if (length($ret) <= $length) {
			return $ret;
		}
	}
	return $ret;
}

sub progress_bar {
	my $width = shift;
	my $chars = shift;
	my $pos = shift;

	return '' if ($width < 1);
	$pos = 1.0 if $pos > 1;

	my $bgch = substr($chars, 0, 1);
	my $fillch = substr($chars, -1, 1);
	my $intermediates = substr($chars, 1, -1);
	my $steps = (length($chars) - 2) * $width;
	$steps ||= $width;

	my $fill = int($width * $pos);
	my $bar = $fillch x $fill;

	if ($intermediates && $fill < $width) {
		$bar .= substr($intermediates, ($steps * $pos) % length($intermediates), 1);
	}

	$bar . ($bgch x ($width - length($bar)))
}

sub progress_init {
	my $source_size = shift;
	my $progress_chars = shift || "  ▁▂▃▄▅▆▇█";
	my @spinner_states = shift || ("-    ", " -   ", "  -  ", "   - ", "    -", "   - ", "  -  ", " -   ");
	my $now = monotime;
	{
		'progress_chars' => $progress_chars,
		'spinner_states' => \@spinner_states,
		'iteration' => 0,
		'source_size' => $source_size,
		'total_bytes_read' => 0,
		'start_time' => $now,
		'last_timestamp' => $now,
		'transfer_rate' => -1,
	}
}

sub bar_init {
	{ 'segments' => [], 'widths' => {} }
}

# Add a string to the bar with a given priority
# 0 is always rendered, >1 are only rendered if there is space, higher values
# dropped first
# A sub may be added which will receive the remaining width as an argument
sub bar_add {
	my $bar = shift;
	my $priority = shift;
	my $content = shift;

	$bar->{'widths'}{$priority} += ref $content ? 1 : length($content);;
	push(@{$bar->{'segments'}}, [$priority, $content]);
}

sub bar_render {
	my $bar = shift;
	my $max_width = shift;

	my $widths = $bar->{'widths'};

	my $width = 0;
	my $priority_limit = 0;
	for my $pri (sort keys %{$widths}) {
		my $pri_width = $widths->{$pri};
		if ($width + $pri_width >= $max_width) {
			$priority_limit = $pri - 1;
			last;
		}
		$priority_limit = $pri;
		$width += $pri_width;
	}

	$priority_limit ||= 0;
	my $remaining_width = $max_width - $width;
	my $ret = '';

	for my $segment (@{$bar->{'segments'}}) {
		my ($priority, $content) = @{$segment};
		if ($priority <= $priority_limit) {
			if (ref $content eq 'CODE') {
				$ret .= &$content($remaining_width);
			} else {
				$ret .= $content;
			}
		}
	}
	$ret;
}

sub progress_update {
	my $state = shift;
	my $bytes_read = shift;
	my $now = shift || monotime();

	my $total_bytes_read = ($state->{'total_bytes_read'} += $bytes_read);
	my $source_size = $state->{'source_size'};
	my $transfer_rate = $state->{'transfer_rate'};
	my $iteration = $state->{'iteration'}++;
	my $last_timestamp = $state->{'last_timestamp'};
	my $total_elapsed = $now - $state->{'start_time'};
	my $elapsed = $now - $last_timestamp;

	$state->{'last_timestamp'} = $now;

	if ($elapsed == 0) { $elapsed = 1; }
	my $current_rate = ( $bytes_read / $elapsed );
	my $overall_rate = ( $total_bytes_read / $total_elapsed);

	if ($transfer_rate == -1) {
		# Set the initial value to the only one we have
		$transfer_rate = $current_rate;
	} else {
		# Exponentially smooth our overall throughput for ETA purposes
		# A higher smoothing value weighs the most recent value less
		my $smoothing = 0.8;
		$transfer_rate = ((1 - $smoothing) * $current_rate) + ($smoothing * $transfer_rate);
	}
	$state->{'transfer_rate'} = $transfer_rate;

	my $remaining_data = $source_size - $total_bytes_read;

	my $eta = '';

	if ($source_size) {
		$eta .= ' ETA ';
		if ($remaining_data && $transfer_rate) {
			$eta .= printable_seconds($remaining_data / $transfer_rate);
		} elsif (!$transfer_rate) {
			$eta .= '??:??:??';
		} else {
			$eta .= '00:00:00';
		}
	}

	# find terminal length, extrapolate bar length
	my ($wchar, $hcar, $wpixels, $hpixels) = GetTerminalSize();
	# no more ridiculously over-long meters please
	if ($wchar > 80) { $wchar = 80; }
	# leave one extra character so we can print a \n to keep things cleaner if user resizes the term
	$wchar -= 1;

	# clear last status line before printing a new one
	print STDERR $clearline if $iteration > 0;

	my $bar = bar_init();

	bar_add($bar, 0, sprintf(' %s [%s] [AVG %s/s',
	                         printable_seconds($total_elapsed),
	                         printable_bytes($total_bytes_read),
							 printable_bytes($overall_rate)));
	bar_add($bar, 1, sprintf(" CUR %s/s", printable_bytes ($current_rate)));
	bar_add($bar, 0, ']');

	if ($source_size) {
		my $fraction_done = ($source_size - $remaining_data) / $source_size;
		$fraction_done = 1.0 if $fraction_done > 1;

		bar_add($bar, 4, ' [');
		bar_add($bar, 4, sub { progress_bar($_[0], $state->{'progress_chars'}, $fraction_done) });
		bar_add($bar, 4, ']');
		bar_add($bar, 3, sprintf(" %3d%%", $fraction_done * 100));
	} else {
		bar_add($bar, 2, ' [' . $state->{'spinner_states'}[$iteration % (scalar(@{$state->{'spinner_states'}}))] . ']');
	}

	bar_add($bar, 2, $eta);

	print STDERR bar_render($bar, $wchar);
}

sub progress_finish() {
	print STDERR "\n";
}