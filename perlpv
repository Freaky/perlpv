#!/usr/bin/env perl

use strict;
use warnings;
use utf8;

use Time::HiRes qw(clock_gettime CLOCK_MONOTONIC alarm);
use Errno qw(EINTR);
use Fcntl qw(O_RDONLY);

# apt install libterm-readkey-perl on Debian derivatives eg Ubuntu
use Term::ReadKey;

# We need to turn off buffering of STDERR to get rapid display of progress.
STDERR->autoflush(1);
binmode(STDERR, ":encoding(UTF-8)");

my $cursorup = "\033[1A";
my $cursordown = "\033[1B";
my $beginline = "\033[1E";
my $cleartoend = "\033[K";
my $clearline = $beginline . $cursorup . $cleartoend;

my $SOURCE = $ARGV[0];
my $TARGET = $ARGV[1];

# Set transfer blocksize to 512KiB. This doesn't appear to affect transfer rate MUCH, at least on my
# (i9-12900K) system. But it does appear SLIGHTLY faster, at least for the inital couple of seconds,
# than using 64KiB.
my $blocksize = 1024 * 512;

my $begin = monotime();

	my $size = open_files($SOURCE, $TARGET, $blocksize);

	transfer_data($size);

	close_files($SOURCE, $TARGET);

my $end = monotime();

exit 0;

sub monotime {
	clock_gettime(CLOCK_MONOTONIC)
}

sub transfer_data {
	my $source_size = shift;

	my $finished = 0;
	my $alarmed = 0;

	# Set up a SIGALRM timer to interrupt us periodically to update statistics
	local $SIG{'ALRM'} = sub {
		$alarmed = 1;
	};

	alarm(0.5, 0.5);

	# Number of bytes from the previous read, 0 at EOF, or -1 on SIGALRM interrupt
	my $bytes_read = -1;

	# Total bytes read since the last progress update
	my $current_bytes_read = 0;

	# Bytes in buffer remaining to write
	my $buffer_pending_bytes = 0;
	my $buffer;

	my $progress = progress_init($source_size || 0);

	# Loop until we have both exhausted the input and cleared the output buffer
	until ($finished) {
		# Try reading if the buffer is empty and we haven't previously hit EOF
		if ($buffer_pending_bytes == 0 && $bytes_read != 0) {
			# Try to refill our empty buffer
			$buffer = '';
			$bytes_read = sysread(SOURCE, $buffer, $blocksize);

			if (defined($bytes_read)) {
				$current_bytes_read += $bytes_read;
				$buffer_pending_bytes = $bytes_read;
			} elsif ($! == EINTR) {
				$bytes_read = -1;
			} else {
				die "Error reading from $SOURCE: $!";
			}
		}

		if ($buffer_pending_bytes != 0) {
			# Try to drain the non-empty buffer
			my $bytes_written = syswrite(TARGET, $buffer, $buffer_pending_bytes,
				length($buffer) - $buffer_pending_bytes);

			if (defined($bytes_written)) {
				$buffer_pending_bytes -= $bytes_written;
			} elsif ($! != EINTR) {
				die $! ? "Error writing to $TARGET: $!" : "Exit status $? from $TARGET";
			}
		}

		$finished = $bytes_read == 0 && $buffer_pending_bytes == 0;

		# Record stats if we've received SIGALRM or have hit EOF and finished writing
		if ($alarmed || $finished) {
			progress_update($progress, $current_bytes_read);

			$alarmed = 0;
			$current_bytes_read = 0;
		}
	}
	print STDERR "\n";
	alarm(0);
}

sub close_files {
	my $SOURCE = shift;
	my $TARGET = shift;

	close SOURCE
		or die $! ? "Error closing source file $SOURCE: $!"
		: "Exit status $? from $SOURCE\n";
	close TARGET
		or die $! ? "Error closing target file $TARGET: $!"
		: "Exit status $? from $TARGET\n";
}

sub open_files {
	my $SOURCE = shift;
	my $TARGET = shift;
	my $blocksize = shift;

	# if SOURCE is a file, a -s check is all we need to find its size
	my $size = -s $SOURCE;

	if (-b $SOURCE || -c $SOURCE) {
		# this is a block device or character device, -s won't work
		open TEST, "<", $SOURCE;
		seek TEST, 0, 2;
		$size = tell TEST;
		close TEST;
	}

	sysopen SOURCE, $SOURCE, O_RDONLY
		or die $! ? "Error opening source file $SOURCE: $!"
		: "Exit status $? from sysopen SOURCE,$SOURCE,O_RDONLY\n";
	binmode SOURCE;

	open TARGET, ">", "$TARGET"
		or die $! ? "Error opening target file $TARGET: $!"
		: "Exit status $? from open TARGET,>,$TARGET\n";
	binmode TARGET;

	return $size;
}

# Formatting and stats functions

sub printable_seconds {
	my $seconds = shift;
	my $printable_seconds;

	my $days = 0;
	my $hours = 0;
	my $minutes = 0;

	if ($seconds >= 60*60*24) {
		$days = sprintf("%d",$seconds/60/60/24);
		$seconds = $seconds - $days*60*60*24;
	}

	if ($seconds >= 60*60) {
		$hours = sprintf("%d",($seconds/60/60));
		$seconds = $seconds - $hours*60*60;
	}

	if ($seconds >=60) {
		$minutes = sprintf("%d",($seconds/60));
		$seconds = $seconds - $minutes*60;
	}

	$hours = sprintf("%02d",$hours);
	$minutes = sprintf("%02d",$minutes);
	$seconds = sprintf("%02d",$seconds);

	$printable_seconds = "$hours:$minutes:$seconds";
	if ($days) { $printable_seconds = "$days days, $printable_seconds"; }

	return $printable_seconds;
}

# ZFS-style number formatting
# Takes a byte size and a character length to fit the formatted value within
sub printable_bytes {
	my $num = shift;
	my $length = shift || 5;

	my @size_prefix = ('B', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y');
	my @formats = ('%*.2f%s', '%*.1f%s', '%*.0f%s');
	my $divisor = 1024;

	my $n = $num;
	my $index = 0;
	while ($n >= $divisor && $index <= ($#size_prefix - 1)) {
		$n /= $divisor;
		$index++;
	}

	my $u = $size_prefix[$index];

	if ($index == 0 || $num % ($divisor ** $index) == 0) {
		return sprintf("%*d%s", $length - 1, $n, $u);
	}

	my $ret;
	foreach my $fmt (@formats) {
		$ret = sprintf($fmt, $length - 1, $n, $u);
		if (length($ret) <= $length) {
			return $ret;
		}
	}
	return $ret;
}

sub progress_bar {
	my $width = shift;
	my $chars = shift;
	my $pos = shift;

	return '' if ($width < 1);

	my $bgch = substr($chars, 0, 1);
	my $fillch = substr($chars, -1, 1);
	my $intermediates = substr($chars, 1, -1);
	my $steps = (length($chars) - 2) * $width;
	$steps ||= $width;

	my $fill = int($width * $pos);
	my $bar = $fillch x $fill;

	if ($intermediates && $fill < $width) {
		$bar .= substr($intermediates, ($steps * $pos) % length($intermediates), 1);
	}

	$bar . ($bgch x ($width - length($bar)))
}

sub progress_init {
	my $source_size = shift;
	my $progress_chars = shift || "  ▁▂▃▄▅▆▇█";
	my @spinner_states = shift || ("-    ", " -   ", "  -  ", "   - ", "    -", "   - ", "  -  ", " -   ");
	my $now = monotime;
	{
		'progress_chars' => $progress_chars,
		'spinner_states' => \@spinner_states,
		'iteration' => 0,
		'source_size' => $source_size,
		'total_bytes_read' => 0,
		'start_time' => $now,
		'last_timestamp' => $now,
		'transfer_rate' => -1,
	}
}

sub progress_update {
	my $state = shift;
	my $bytes_read = shift;
	my $now = shift || monotime();

	my $total_bytes_read = ($state->{'total_bytes_read'} += $bytes_read);
	my $source_size = $state->{'source_size'};
	my $transfer_rate = $state->{'transfer_rate'};
	my $iteration = $state->{'iteration'}++;
	my $last_timestamp = $state->{'last_timestamp'};
	my $total_elapsed = $now - $state->{'start_time'};
	my $elapsed = $now - $last_timestamp;

	$state->{'last_timestamp'} = $now;

	if ($elapsed == 0) { $elapsed = 1; }
	my $current_rate = ( $bytes_read / $elapsed );
	my $overall_rate = ( $total_bytes_read / $total_elapsed);

	if ($transfer_rate == -1) {
		# Set the initial value to the only one we have
		$transfer_rate = $current_rate;
	} else {
		# Exponentially smooth our overall throughput for ETA purposes
		# A higher smoothing value weighs the most recent value higher
		my $smoothing = 0.8;
		$transfer_rate = ((1 - $smoothing) * $current_rate) + ($smoothing * $transfer_rate);
	}
	$state->{'transfer_rate'} = $transfer_rate;

	my $remaining_data = $source_size - $total_bytes_read;

	my $eta = '';

	if ($source_size) {
		$eta .= ' ETA ';
		if ($remaining_data && $transfer_rate) {
			$eta .= printable_seconds($remaining_data / $transfer_rate);
		} elsif (!$transfer_rate) {
			$eta .= '??:??:??';
		} else {
			$eta .= '00:00:00';
		}
	}

	# find terminal length, extrapolate bar length
	my ($wchar, $hcar, $wpixels, $hpixels) = GetTerminalSize();
	# no more ridiculously over-long meters please
	if ($wchar > 80) { $wchar = 80; }
	# leave one extra character so we can print a \n to keep things cleaner if user resizes the term
	$wchar -= 1;

	# Avoid erasing existing terminal contents
	print STDERR "\n" unless ($iteration);

	# clear last status line before printing a new one
	print STDERR $clearline;

	# now build the meter output
	my $message = sprintf(" %s [%s] [AVG %s/s", printable_seconds($total_elapsed),
	                      printable_bytes($total_bytes_read), printable_bytes($overall_rate));

	# check to make sure there's room to display both rates, drop CUR if necessary
	if ($wchar >= 65) { $message .= sprintf(" CUR %s/s", printable_bytes ($current_rate)); }
	$message.= "] ";

	my $message_length = length($message) + length($eta);
	my $available_space = $wchar - $message_length;
	my $bartext = '';

	if ($source_size) {
		my $fraction_done = ($source_size - $remaining_data) / $source_size;

		# Assuming a single char progress bar is usable
		if ($available_space >= 8) {
			my $barlength = $available_space - 7;
			$bartext .= '[' . progress_bar($barlength, $state->{'progress_chars'}, $fraction_done) . ']'
		}

		if ($available_space >= 5) {
			$bartext .= sprintf(" %3d%%", $fraction_done * 100);
		}
	} elsif ($available_space >= length($state->{'spinner_states'}[0]) + 2) {
		$bartext .= '[' . $state->{'spinner_states'}[$iteration % (scalar(@{$state->{'spinner_states'}}))] . ']';
	}

	$message .= $bartext . $eta;

	print STDERR $message;
}
